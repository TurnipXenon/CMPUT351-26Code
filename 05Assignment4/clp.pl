%*****************************************************************************************
% Question 1
% 5 examples of removal of domain values:
% In row 1, column 1,
% (1) 1 is removed from the domain because 1 is already in the same box
% (2) 2 is removed from the domain because 2 is already in the same row
% (3) 3 is removed from the domain because 3 is already in the same box
% (4) 6 is removed from the domain because 6 is already in the same row
% (5) 7 is removed from the domain because 7 is already in the same column
% 1 example of domain values that cannot be removed by AC-3
% In row 1, column 1,
% {4, 9} cannot be removed from the domain, because neither 4 nor 9 are in the same box,
% same column, or same row. Assuming we did AC-3 on every tile in Example 2, row-1-column-1
% still has no 4's nor 9's in the same box, same column, or same row in the image shown
% in the website where it shows the AC-3 output.



%*****************************************************************************************
% Question 2
% encrypt(+W1, +W2, +W3): addition of values W1 and W2 equals that of W3. Assume that W1 and
% W2 are of the same length.
%
% Test case(s):
% encrypt([S, E, N, D], [M, O, R, E], [M, O, N, E, Y]).
% > S = 9, E = 5, N = 6, D = 7, M = 1, O = 0, R = 8, Y = 2 
% encrypt([I,T], [I,S], [M,E]). 
% > E = 0, I = 1, M = 3, S = 8, T = 2

:- use_module(library(clpfd)).

encrypt(W1,W2,W3) :- 
   length(W1,N), % if you need to know the lengths of words
   length(W3,N1),   
   append(W1,W2,W),
   append(W,W3,L),
   list_to_set(L, Letters), % remove duplicates, a predicate in list library
   [LeadLetter1|_] = W1, % identify the leading letter to be set to non-zero
   [LeadLetter2|_] = W2,
   [LeadLetter3|_] = W3,
   all_distinct(Letters),
   sum_constraint(LeadLetter3, N, N1),
   Sum4 #= Sum3,
   LeadLetter1 #\= 0,
   LeadLetter2 #\= 0,
   LeadLetter3 #\= 0,
   get_sum(W1, Sum1),
   get_sum(W2, Sum2),
   Sum3 #= Sum1 + Sum2,
   get_sum(W3, Sum4),
   Letters ins 0..9,
   !, % never need to redo the above
   label(Letters).


% sum_constraint(+Letter, +N1, +N2): adds a constraint #=1 on Letter if N1 != N2

sum_constraint(_, A, A) :- !.
sum_constraint(Letter, _, _) :- Letter #= 1.


% get_sum(+L, -Sum): returns domain Sum where it is equal to number if each atom in L
% were to be assigned a digit

get_sum([], 0).
get_sum([A|L], Sum) :-
   length([A|L], Len),
   Exp is Len - 1,
   power(10, Exp, P),
   Sum1 #= A*P,
   get_sum(L, Sum2),
   Sum #= Sum1 + Sum2.


% power(+Base, +Exp, -Result): returns Result where Result = Base ^ Exp

power(_, 0, 1) :- !.
power(Base, Exp, Result) :-
   Exp1 is Exp - 1,
   power(Base, Exp1, Result1),
   Result is Result1 * Base.



%*****************************************************************************************
% Question 3
% subsetsum(+Subset, +Sum)
%
% Test case(s):
% subsetsum([-1, 1, 2, 3, 7,9,-2, -4],18). > True

subsetsum(Multiset, Sum) :-
   length(Multiset, Len),
   length(Subset, Len),
   assign_domain(Subset, Multiset),
   sum(Subset, #=, Sum),
   !,
   label(Subset),
   print(Subset),
   !.


% assign_domain(+Subset, +Domain): Assigns each variable i in Subset to have a domain of either
% 0 or the value i in Domain

assign_domain([], _).
assign_domain([A|Subset], [B|Domain]) :-
   A in 0\/B,
   assign_domain(Subset, Domain).



%*****************************************************************************************
% Question 4
% What we want is a paper review assignment satisfying
% (1) No one reviews his/her own paper;
% (2) A reviewer must have the expertise to review the assigned paper, i.e., one of the reviewers' subject areas of expertise must match the subject area of the paper;
% (3) Each paper is assigned to 2 reviewers; and
% (4) No reviewer is assigned more than k papers, where k will be given by a fact: workLoadAtMost(k).
% You should write a program, so that a paper assignment is generated by
%
% Usage:
% assign(-W1, -W2) :- returns the paper review assignment based on the above criteria.

assign(W1,W2) :-
   retract_data(), % remove previous data
   findall(P, paper(P, _, _, _), Papers),
   findall(A, (reviewer(A, _, _)), Reviewers),
   findall(T, paper(_, _, _, T), Topics),
   % digitize the atoms
   digitize_topic(Topics, 1),
   digitize_reviewers(Reviewers, 1),
   digitize_paper(Papers),
   workLoadAtMost(MaxLoad),
   % fill out W1
   length(Papers, Len),
   length(W1, Len),
   length(WI1, Len),
   length(W2, Len),
   length(WI2, Len),
   append(WI1, WI2, WI3),
   % add the constraints
   experty_review(WI1, 1),
   nonExpertReview(WI2),
   noSelfReview(WI1, WI2, 1),
   paper_has_two_reviewers(WI1, WI2),
   !,
   label(WI3),
   consider_max_load(WI3, MaxLoad),
   assignRealNames(W1, WI1),
   assignRealNames(W2, WI2).


% digitize_topic(+T, +Id): digitize or assign IDs to the textual topics

digitize_topic([], _).
digitize_topic([T|Topics], Id) :-
   assert(topicId(Id, T)),
   Id1 is Id + 1,
   digitize_topic(Topics, Id1).

topicId(_, _) :- false. % prevent warnings


% digitize_reviewers(+R, Id): digitize or assign IDs to the textual name of the reviewers

digitize_reviewers([], _).
digitize_reviewers([R|Reviewers], Id) :-
   reviewer(R, T1, T2),
   topic_to_id(T1, TI1),
   topic_to_id(T2, TI2),
   assert(reviewerId(Id, R)),
   assert(reviewerDataId(Id, TI1, TI2)),
   Id1 is Id + 1,
   digitize_reviewers(Reviewers, Id1).

reviewerId(_, _) :- false. % prevent warnings


% retract_data(): remove all digitized IDs

retract_data() :-
   topicId(_, _),
   retractall(topicId(_, _)),
   reviewerId(_, _),
   retractall(reviewerId(_, _)),
   reviewerDataId(_, _, _),
   retractall(reviewerDataId(_, _, _)),
   reviewerDataId(_, _, _)
   retractall(paperId(_, _, _, _)),
   !.

retract_data().


% digitize_paper(+Paper): digitize or assign IDs to all textual data of a paper

digitize_paper([]).
digitize_paper([P|Papers]) :-
   paper(P, R1, R2, T),
   reviewer_to_id(R1, RI1),
   reviewer_to_id(R2, RI2),
   topic_to_id(T, TI),
   assert(paperId(P, RI1, RI2, TI)),
   digitize_paper(Papers).


% reviewer_to_id(+Reviewer, -Id): returns the Id for a given Reviewer, or it returns 0 if they
% are not declared using reviewer(Reviewer, _, _)

reviewer_to_id(R, RI) :-
   reviewerId(RI, R),
   !.
reviewer_to_id(_, 0). % non-registered reviewer 


% topic_to_id(+Topic, -Id): returns the Id for a given topic, or it returns 0 if they
% are not declared using paper(_, _, _, Topic)

topic_to_id(T, TI) :-
   topicId(TI, T),
   !.
topic_to_id(_, 0).


% no_self_review(+R1, +R2, +Id): assigns a constraint on each i-th variable in R1 and R2
% so that they are not assigned to writer of the i-th paper

noSelfReview([], _, _).
noSelfReview([W1|L1], [W2|L2], Id) :-
   paperId(Id, R1, R2, _),
   W1 #\= R1,
   W1 #\= R2,
   W2 #\= R1,
   W2 #\= R2,
   Id1 is Id + 1,
   noSelfReview(L1, L2, Id1).

paperId(-1, _, _, _) :- false. % prevent warning


% get_domain_union(+List_To_Domain, -Domain): turns a non-empty list into a clpfd domain

get_domain_union([El|[]], FdDomain) :-
   !,
   fd_dom(El, FdDomain).
get_domain_union([El|Domain], FdDomain) :-
   get_domain_union(Domain, FdDomain1),
   B in El\/FdDomain1,
   fd_dom(B, FdDomain).


% experty_review(+Reviewers, +Id): assigns a constraint each reviewer in Reviewers so that
% only reviewers expert on the i-th paper's topic can be assigned on the i-th reviewer

experty_review([], _).
experty_review([W1|L1], Id) :-
   paperId(Id, _, _, T),
   findall(R, (reviewerDataId(R, T, _); reviewerDataId(R, _, T)), RL),
   get_domain_union(RL, RD),
   W1 in RD,
   Id1 is Id + 1,
   experty_review(L1,Id1).


% non_experty_review(+Reviewers): assigns a constraint on each reviewer in Reviewers so
% that their domain is all the reviewers

nonExpertReview([]).
nonExpertReview(W1) :-
   findall(R, reviewerDataId(R, _, _), RL),
   get_domain_union(RL, RD),
   W1 ins RD.

reviewerDataId(_, _, _) :- false. % prevent warning


% paper_has_two_reviewers(+Reviewers1, +Reviewers2): adds a constraint so that the i-th
% reviewer in Reviewers1 is not equal to the i-th reviewer in Reviewers2

paper_has_two_reviewers([], _).
paper_has_two_reviewers([W1|L1], [W2|L2]) :-
   W1 #\= W2,
   paper_has_two_reviewers(L1, L2).


% consider_max_load(+Researchers, +LoadMax): returns true if no reviewers exceed the max load
% otherwise false

consider_max_load([], _).
consider_max_load([R|L], LoadMax) :-
   count(R, L, C),
   C < LoadMax,
   consider_max_load(L, LoadMax).


% count(+Element, +List, -N): returns an integer N representing how many element Element is in
% list List

count(_, [], 0) :- !.
count(X, [X|L], N) :-
   !,
   count(X, L, N1),
   N is N1 + 1.
count(X, [_|L], N) :-
   count(X, L, N).


% assign_real_names(+Reviewers, -ReviewerIds): assigns the equivalent textual name for the
% textual name of the reviewer on the i-th element in Reviewers based on the i-th element
% in ReviewerIds

assignRealNames([], _).
assignRealNames([W|WL], [I|IL]) :-
   reviewerId(I, R),
   W = R,
   assignRealNames(WL, IL).