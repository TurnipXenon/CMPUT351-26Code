%*****************************************************************************************
% Question 1



%*****************************************************************************************
% Question 2
% encrypt(+W1, +W2, +W3): addition of values W1 and W2 equals that of W3. Assume that W1 and
% W2 are of the same length.

% encrypt(E, D, 2).

:- use_module(library(clpfd)).

% encrypt([S, E, N, D], [M, O, R, E], [M, O, N, E, Y]).
encrypt(W1,W2,W3) :- 
   length(W1,N), % if you need to know the lengths of words
   length(W3,N1),   
   append(W1,W2,W),
   append(W,W3,L),
   list_to_set(L, Letters), % remove duplicates, a predicate in list library
   [LeadLetter1|_] = W1, % identify the leading letter to be set to non-zero
   [LeadLetter2|_] = W2,
   [LeadLetter3|_] = W3,
   !, % never need to redo the above
   all_diff(Letters),
   sum_constraint(LeadLetter3, N, N1),
   Sum4 #= Sum3,
   LeadLetter1 #\= 0,
   LeadLetter2 #\= 0,
   LeadLetter3 #\= 0,
   get_sum(W1, Sum1),
   get_sum(W2, Sum2),
   Sum3 #= Sum1 + Sum2,
   get_sum(W3, Sum4),
   Letters ins 0..9,
   label(Letters).

sum_constraint(_, A, A) :- !.
sum_constraint(Letter, _, _) :- Letter #= 1.

get_sum([], 0).
get_sum([A|L], Sum) :-
   length([A|L], Len),
   Exp is Len - 1,
   power(10, Exp, P),
   Sum1 #= A*P,
   get_sum(L, Sum2),
   Sum #= Sum1 + Sum2.

power(_, 0, 1) :- !.
power(Base, Exp, Result) :-
   Exp1 is Exp - 1,
   power(Base, Exp1, Result1),
   Result is Result1 * Base.

all_diff([_]).
all_diff([A|L]) :-
   diff(A, L),
   all_diff(L).

diff(_, []).
diff(A, [B|L]) :-
   A #\= B,
   diff(A,L).



%*****************************************************************************************
% Question 3
% subsetsum(+Subset, +Sum)

% subsetsum([-1, 1, 2, 3, 7,9,-2, -4],18).
% subsetsum([-1, 1, 2, 3, 7,9,-2, -4],18,S).

% Multiset = [-1, 1, 2, 3, 7,9,-2, -4], Sum = 18, length(Multiset, Len), length(Subset, Len), assign_domain(Subset, Multiset), get_subset_sum(Subset, SubsetSum), SubsetSum #= Sum.

subsetsum(Multiset, Sum) :-
   length(Multiset, Len),
   length(Subset, Len),
   assign_domain(Subset, Multiset),
   get_subset_sum(Subset, SubsetSum),
   SubsetSum #= Sum,
   !,
   label(Subset),
   print(Subset),
   !.


get_subset_sum([], 0).
get_subset_sum([A|L], Sum) :-
   get_subset_sum(L, Sum2),
   Sum #= A + Sum2.


assign_domain([], _).
assign_domain([A|Subset], [B|Domain]) :-
   A in 0\/B,
   assign_domain(Subset, Domain).


getDomainUnion([El|[]], FdDomain) :-
   !,
   fd_dom(El, FdDomain).
getDomainUnion([El|Domain], FdDomain) :-
   getDomainUnion(Domain, FdDomain1),
   B in El\/FdDomain1,
   fd_dom(B, FdDomain).

% xSubsetsum([], _, _).
% xSubsetsum([A|Subset], Multiset, Sum) :-
%    xSubsetsum(Subset, Multiset1, Sum).

is_multiset_subset([], _).
is_multiset_subset([0|Subset], Multiset) :-
   !,
   is_multiset_subset(Subset, Multiset).
is_multiset_subset([A|Subset], Multiset) :-
   select(A, Multiset, Multiset2),
   !,
   is_multiset_subset(Subset, Multiset2).


%*****************************************************************************************
% Question 4
% What we want is a paper review assignment satisfying
% (1) No one reviews his/her own paper;
% (2) A reviewer must have the expertise to review the assigned paper, i.e., one of the reviewers' subject areas of expertise must match the subject area of the paper;
% (3) Each paper is assigned to 2 reviewers; and
% (4) No reviewer is assigned more than k papers, where k will be given by a fact: workLoadAtMost(k).
% You should write a program, so that a paper assignment is generated by
% ?-   assign(W1,W2).

assign(W1,W2,WI1,WI2) :-
   findall(P, paper(P, _, _, _), Papers),
   findall(A, (reviewer(A, _, _)), Reviewers),
   findall(T, paper(_, _, _, T), Topics),
   % digitize the atoms
   identifyTopic(Topics, 1),
   identifyReviewers(Reviewers, 1),
   digitizePaper(Papers),
   workLoadAtMost(MaxLoad),
   % fill out W1
   length(Papers, Len),
   length(W1, Len),
   length(WI1, Len),
   length(W2, Len),
   length(WI2, Len),
   % add the constraints
   expertyReview(WI1, WI2, 1),
   noSelfReview(WI1, WI2, 1),
   paperHasTwoReviewers(WI1, WI2),
   considerMaxLoad(),
   !,
   labeling([ff], WI1),
   labeling([ff], WI2),
   assignRealNames(W1, WI1),
   assignRealNames(W2, WI2),
   retractData().
   

identifyTopic([], _).
identifyTopic([T|Topics], Id) :-
   assert(topicId(Id, T)),
   Id1 is Id + 1,
   identifyTopic(Topics, Id1).

identifyReviewers([], _).
identifyReviewers([R|Reviewers], Id) :-
   reviewer(R, T1, T2),
   topicToId(T1, TI1),
   topicToId(T2, TI2),
   assert(reviewerId(Id, R)),
   assert(reviewerDataId(Id, TI1, TI2)),
   Id1 is Id + 1,
   identifyReviewers(Reviewers, Id1).

retractData() :-
   retractall(topicId(_, _)),
   retractall(reviewerId(_, _)),
   retractall(paperId(_, _, _, _)).

digitizePaper([]).
digitizePaper([P|Papers]) :-
   paper(P, R1, R2, T),
   reviewerToId(R1, RI1),
   reviewerToId(R2, RI2),
   topicToId(T, TI),
   assert(paperId(P, RI1, RI2, TI)),
   digitizePaper(Papers).

reviewerToId(R, RI) :-
   reviewerId(RI, R),
   !.
reviewerToId(_, 0). % non-registered reviewer 

topicToId(T, TI) :-
   topicId(TI, T),
   !.
topicToId(_, 0).

noSelfReview([], _, _).
noSelfReview([W1|L1], [W2|L2], Id) :-
   paperId(Id, R1, R2, _),
   W1 #\= R1,
   W1 #\= R2,
   W2 #\= R1,
   W2 #\= R2,
   Id1 is Id + 1,
   noSelfReview(L1, L2, Id1).

expertyReview([], _, _).
expertyReview([W1|L1], [W2|L2], Id) :-
   paperId(Id, _, _, T),
   findall(R, (reviewerDataId(R, T, _); reviewerDataId(R, _, T)), RL),
   getDomainUnion(RL, RD),
   W1 in RD,
   W2 in RD,
   Id1 is Id + 1,
   expertyReview(L1, L2, Id1).

assignDomain4(_, _, []).
assignDomain4(W1, W2, [T|L]) :-
   W1 in T,
   W2 in T,
   assignDomain4(W1, W2, L).

paperHasTwoReviewers([], _).
paperHasTwoReviewers([W1|L1], [W2|L2]) :-
   W1 #\= W2,
   paperHasTwoReviewers(L1, L2).

% todo
considerMaxLoad().

%todo
assignRealNames([], _).
assignRealNames([W|WL], [I|IL]) :-
   reviewerId(I, R),
   W = R,
   assignRealNames(WL, IL).

% definePaperNumber([], _, _).
% definePaperNumber([P|Papers], Reviewers, Topics) :-

%    assert(paper(P, RI1, RI2, TI)),
%    definePaperNumber(Papers, Reviewers, Topics).

% paperNumber().

% constrainPaper([], [], _, _).
% constrainPaper([R1|W1], [R2|W2], Reviewers, Index) :-
%    paper(Index, Author1, Author2, _),
%    R1 in Reviewers,
%    R2 in Reviewers,
%    % R1 =\= Author1,
%    % R2 =\= Author1,
%    % R1 =\= Author2,
%    % R2 =\= Author2,
%    Index1 is Index + 1,
%    constrainPaper(W1, W2, Reviewers, Index1).

% consOwnPaper([]).
% consOwnPaper([R|L]) :-
%    xConsOwnPaper(R),
%    consOwnPaper(L).

% xConsOwnPaper(R) :-
%    findall(P1, paper(P1, R, _, _), Papers1),
%    findall(P2, paper(P2, _, R, _), Papers2),
%    append(Papers1, Papers2, Papers3),
%    dontReview(R, Papers3).

% dontReview(_, []).
% dontReview(Reviewer, [P|L]) :-
%    .

% example

paper(1,lily,xxx,ai).
paper(2,peter,john,database).
paper(3,ann,xxx,theory).
paper(4,ken,lily,network).
paper(5,kris,xxx,games).

reviewer(lily,theory,network).
reviewer(john,ai,theory).
reviewer(peter,database,network).
reviewer(ann,theory,network).
reviewer(kris,theory,games).
reviewer(ken,database,games).
reviewer(bill,database,ai).
reviewer(jim,theory,games).

workLoadAtMost(2).