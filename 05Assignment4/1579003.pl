%*****************************************************************************************
% Question 1



%*****************************************************************************************
% Question 2
% encrypt(+W1, +W2, +W3): addition of values W1 and W2 equals that of W3. Assume that W1 and
% W2 are of the same length.

% encrypt(E, D, 2).

:- use_module(library(clpfd)).

% encrypt([S, E, N, D], [M, O, R, E], [M, O, N, E, Y]).
encrypt(W1,W2,W3) :- 
   length(W1,N), % if you need to know the lengths of words
   length(W3,N1),   
   append(W1,W2,W),
   append(W,W3,L),
   list_to_set(L, Letters), % remove duplicates, a predicate in list library
   [LeadLetter1|_] = W1, % identify the leading letter to be set to non-zero
   [LeadLetter2|_] = W2,
   [LeadLetter3|_] = W3,
   !, % never need to redo the above
   all_diff(Letters),
   sum_constraint(LeadLetter3, N, N1),
   Sum4 #= Sum3,
   LeadLetter1 #\= 0,
   LeadLetter2 #\= 0,
   LeadLetter3 #\= 0,
   get_sum(W1, Sum1),
   get_sum(W2, Sum2),
   Sum3 #= Sum1 + Sum2,
   get_sum(W3, Sum4),
   Letters ins 0..9,
   label(Letters).

sum_constraint(_, A, A) :- !.
sum_constraint(Letter, _, _) :- Letter #= 1.

get_sum([], 0).
get_sum([A|L], Sum) :-
   length([A|L], Len),
   Exp is Len - 1,
   power(10, Exp, P),
   Sum1 #= A*P,
   get_sum(L, Sum2),
   Sum #= Sum1 + Sum2.

power(_, 0, 1) :- !.
power(Base, Exp, Result) :-
   Exp1 is Exp - 1,
   power(Base, Exp1, Result1),
   Result is Result1 * Base.

all_diff([_]).
all_diff([A|L]) :-
   diff(A, L),
   all_diff(L).

diff(_, []).
diff(A, [B|L]) :-
   A #\= B,
   diff(A,L).



%*****************************************************************************************
% Question 3
% subsetsum(+Subset, +Sum)

% subsetsum([-1, 1, 2, 3, 7,9,-2, -4],18).
% subsetsum([-1, 1, 2, 3, 7,9,-2, -4],18,S).

% Multiset = [-1, 1, 2, 3, 7,9,-2, -4], Sum = 18, length(Multiset, Len), length(Subset, Len), assign_domain(Subset, Multiset), get_subset_sum(Subset, SubsetSum), SubsetSum #= Sum.

subsetsum(Multiset, Sum) :-
   length(Multiset, Len),
   length(Subset, Len),
   assign_domain(Subset, Multiset),
   get_subset_sum(Subset, SubsetSum),
   SubsetSum #= Sum,
   !,
   labeling([ff], Subset),
   is_multiset_subset(Subset, Multiset),
   !.
   % !.%,
   % label(Subset).
   %xSubsetsum(Subset, Multiset, Sum),
   % sumSubset(Subset, NewSum),
   % NewSum #= Sum.


get_subset_sum([], 0).
get_subset_sum([A|L], Sum) :-
   get_subset_sum(L, Sum2),
   Sum #= A + Sum2.


assign_domain([], _).
assign_domain([A|Subset], Domain) :-
   get_domain_union(Domain, FdDomain),
   A in FdDomain,
   assign_domain(Subset, Domain).


get_domain_union([], 0).
get_domain_union([El|Domain], FdDomain) :-
   get_domain_union(Domain, FdDomain1),
   B in El\/FdDomain1,
   fd_dom(B, FdDomain).

% xSubsetsum([], _, _).
% xSubsetsum([A|Subset], Multiset, Sum) :-
%    xSubsetsum(Subset, Multiset1, Sum).

is_multiset_subset([], _).
is_multiset_subset([0|Subset], Multiset) :-
   !,
   is_multiset_subset(Subset, Multiset).
is_multiset_subset([A|Subset], Multiset) :-
   select(A, Multiset, Multiset2),
   !,
   is_multiset_subset(Subset, Multiset2).


%*****************************************************************************************
% Question 4
% What we want is a paper review assignment satisfying
% (1) No one reviews his/her own paper;
% (2) A reviewer must have the expertise to review the assigned paper, i.e., one of the reviewers' subject areas of expertise must match the subject area of the paper;
% (3) Each paper is assigned to 2 reviewers; and
% (4) No reviewer is assigned more than k papers, where k will be given by a fact: workLoadAtMost(k).
% You should write a program, so that a paper assignment is generated by
% ?-   assign(W1,W2).

% assign(W1,W2) :-
%    findall(P, paper(P, _, _, _), Papers),
%    findall(A, reviewer(A, _, _), Reviewers),
%    length(Papers, PLen),
%    length(W1, PLen),
%    length(W2, PLen),
%    constrainPaper(W1, W2, Reviewers, 1) % assumes both paper lens are equal
%    .
%    % findall(A, reviewer(A, _, _), Reviewers),
%    % consOwnPaper(Reviewers).

% constrainPaper([], [], _, _).
% constrainPaper([R1|W1], [R2|W2], Reviewers, Index) :-
%    paper(Index, Author1, Author2, _),
%    R1 in Reviewers,
%    R2 in Reviewers,
%    % R1 =\= Author1,
%    % R2 =\= Author1,
%    % R1 =\= Author2,
%    % R2 =\= Author2,
%    Index1 is Index + 1,
%    constrainPaper(W1, W2, Reviewers, Index1).

% consOwnPaper([]).
% consOwnPaper([R|L]) :-
%    xConsOwnPaper(R),
%    consOwnPaper(L).

% xConsOwnPaper(R) :-
%    findall(P1, paper(P1, R, _, _), Papers1),
%    findall(P2, paper(P2, _, R, _), Papers2),
%    append(Papers1, Papers2, Papers3),
%    dontReview(R, Papers3).

% dontReview(_, []).
% dontReview(Reviewer, [P|L]) :-
%    .

% example

% paper(1,lily,xxx,ai).
% paper(2,peter,john,database).
% paper(3,ann,xxx,theory).
% paper(4,ken,lily,network).
% paper(5,kris,xxx,games).

% reviewer(lily,theory,network).
% reviewer(john,ai,theory).
% reviewer(peter,database,network).
% reviewer(ann,theory,network).
% reviewer(kris,theory,games).
% reviewer(ken,database,games).
% reviewer(bill,database,ai).
% reviewer(jim,theory,games).


% workLoadAtMost(2).