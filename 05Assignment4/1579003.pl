%*****************************************************************************************
% Question 1
% 5 examples of removal of domain values:
% In row 1, column 1,
% (1) 1 is removed from the domain because 1 is already in the same box
% (2) 2 is removed from the domain because 2 is already in the same row
% (3) 3 is removed from the domain because 3 is already in the same box
% (4) 6 is removed from the domain because 6 is already in the same row
% (5) 7 is removed from the domain because 7 is already in the same column
% 1 example of domain values that cannot be removed by AC-3
% In row 1, column 1,
% {4, 9} cannot be removed from the domain, because neither 4 nor 9 are in the same box,
% same column, or same row. Assuming we did AC-3 on every tile in Example 2, row-1-column-1
% still has no 4's nor 9's in the same box, same column, or same row in the image shown
% in the website where it shows the AC-3 output.



%*****************************************************************************************
% Question 2
% encrypt(+W1, +W2, +W3): addition of values W1 and W2 equals that of W3. Assume that W1 and
% W2 are of the same length.

% encrypt(E, D, 2).

:- use_module(library(clpfd)).

% encrypt([S, E, N, D], [M, O, R, E], [M, O, N, E, Y]).
encrypt(W1,W2,W3) :- 
   length(W1,N), % if you need to know the lengths of words
   length(W3,N1),   
   append(W1,W2,W),
   append(W,W3,L),
   list_to_set(L, Letters), % remove duplicates, a predicate in list library
   [LeadLetter1|_] = W1, % identify the leading letter to be set to non-zero
   [LeadLetter2|_] = W2,
   [LeadLetter3|_] = W3,
   !, % never need to redo the above
   all_diff(Letters),
   sum_constraint(LeadLetter3, N, N1),
   Sum4 #= Sum3,
   LeadLetter1 #\= 0,
   LeadLetter2 #\= 0,
   LeadLetter3 #\= 0,
   get_sum(W1, Sum1),
   get_sum(W2, Sum2),
   Sum3 #= Sum1 + Sum2,
   get_sum(W3, Sum4),
   Letters ins 0..9,
   label(Letters).

sum_constraint(_, A, A) :- !.
sum_constraint(Letter, _, _) :- Letter #= 1.

get_sum([], 0).
get_sum([A|L], Sum) :-
   length([A|L], Len),
   Exp is Len - 1,
   power(10, Exp, P),
   Sum1 #= A*P,
   get_sum(L, Sum2),
   Sum #= Sum1 + Sum2.

power(_, 0, 1) :- !.
power(Base, Exp, Result) :-
   Exp1 is Exp - 1,
   power(Base, Exp1, Result1),
   Result is Result1 * Base.

all_diff([_]).
all_diff([A|L]) :-
   diff(A, L),
   all_diff(L).

diff(_, []).
diff(A, [B|L]) :-
   A #\= B,
   diff(A,L).



%*****************************************************************************************
% Question 3
% subsetsum(+Subset, +Sum)

% subsetsum([-1, 1, 2, 3, 7,9,-2, -4],18).
% subsetsum([-1, 1, 2, 3, 7,9,-2, -4],18,S).

% Multiset = [-1, 1, 2, 3, 7,9,-2, -4], Sum = 18, length(Multiset, Len), length(Subset, Len), assign_domain(Subset, Multiset), get_subset_sum(Subset, SubsetSum), SubsetSum #= Sum.

subsetsum(Multiset, Sum) :-
   length(Multiset, Len),
   length(Subset, Len),
   assign_domain(Subset, Multiset),
   sum(Subset, #=, Sum),
   % get_subset_sum(Subset, SubsetSum),
   % SubsetSum #= Sum,
   !,
   label(Subset),
   print(Subset),
   !.


get_subset_sum([], 0).
get_subset_sum([A|L], Sum) :-
   get_subset_sum(L, Sum2),
   Sum #= A + Sum2.


assign_domain([], _).
assign_domain([A|Subset], [B|Domain]) :-
   A in 0\/B,
   assign_domain(Subset, Domain).


getDomainUnion([El|[]], FdDomain) :-
   !,
   fd_dom(El, FdDomain).
getDomainUnion([El|Domain], FdDomain) :-
   getDomainUnion(Domain, FdDomain1),
   B in El\/FdDomain1,
   fd_dom(B, FdDomain).

is_multiset_subset([], _).
is_multiset_subset([0|Subset], Multiset) :-
   !,
   is_multiset_subset(Subset, Multiset).
is_multiset_subset([A|Subset], Multiset) :-
   select(A, Multiset, Multiset2),
   !,
   is_multiset_subset(Subset, Multiset2).


%*****************************************************************************************
% Question 4
% What we want is a paper review assignment satisfying
% (1) No one reviews his/her own paper;
% (2) A reviewer must have the expertise to review the assigned paper, i.e., one of the reviewers' subject areas of expertise must match the subject area of the paper;
% (3) Each paper is assigned to 2 reviewers; and
% (4) No reviewer is assigned more than k papers, where k will be given by a fact: workLoadAtMost(k).
% You should write a program, so that a paper assignment is generated by
% ?-   assign(W1,W2).

assign(W1,W2, WI1, WI2) :-
   retractData(),
   findall(P, paper(P, _, _, _), Papers),
   findall(A, (reviewer(A, _, _)), Reviewers),
   findall(T, paper(_, _, _, T), Topics),
   % digitize the atoms
   identifyTopic(Topics, 1),
   identifyReviewers(Reviewers, 1),
   digitizePaper(Papers),
   workLoadAtMost(MaxLoad),
   % fill out W1
   length(Papers, Len),
   length(W1, Len),
   length(WI1, Len),
   length(W2, Len),
   length(WI2, Len),
   append(WI1, WI2, WI3),
   % add the constraints
   expertyReview(WI1, 1),
   nonExpertReview(WI2, 1),
   noSelfReview(WI1, WI2, 1),
   paperHasTwoReviewers(WI1, WI2),
   considerMaxLoad(WI3, MaxLoad),
   !,
   label(WI3),
   assignRealNames(W1, WI1),
   assignRealNames(W2, WI2).

identifyTopic([], _).
identifyTopic([T|Topics], Id) :-
   assert(topicId(Id, T)),
   Id1 is Id + 1,
   identifyTopic(Topics, Id1).

topicId(_, _) :- false.

identifyReviewers([], _).
identifyReviewers([R|Reviewers], Id) :-
   reviewer(R, T1, T2),
   topicToId(T1, TI1),
   topicToId(T2, TI2),
   assert(reviewerId(Id, R)),
   assert(reviewerDataId(Id, TI1, TI2)),
   Id1 is Id + 1,
   identifyReviewers(Reviewers, Id1).

% prevent warnings
reviewerId(_, _) :- false.
reviewerDataId(_, _, _) :- false.

retractData() :-
   topicId(_, _),
   !,
   retractall(topicId(_, _)),
   retractall(reviewerId(_, _)),
   retractall(reviewerDataId(_, _, _)),
   retractall(paperId(_, _, _, _)).
retractData().

digitizePaper([]).
digitizePaper([P|Papers]) :-
   paper(P, R1, R2, T),
   reviewerToId(R1, RI1),
   reviewerToId(R2, RI2),
   topicToId(T, TI),
   assert(paperId(P, RI1, RI2, TI)),
   digitizePaper(Papers).

reviewerToId(R, RI) :-
   reviewerId(RI, R),
   !.
reviewerToId(_, 0). % non-registered reviewer 

topicToId(T, TI) :-
   topicId(TI, T),
   !.
topicToId(_, 0).

noSelfReview([], _, _).
noSelfReview([W1|L1], [W2|L2], Id) :-
   paperId(Id, R1, R2, _),
   W1 #\= R1,
   W1 #\= R2,
   W2 #\= R1,
   W2 #\= R2,
   Id1 is Id + 1,
   noSelfReview(L1, L2, Id1).

paperId(-1, _, _, _) :- false. % prevent warning

expertyReview([], _).
expertyReview([W1|L1], Id) :-
   paperId(Id, _, _, T),
   findall(R, (reviewerDataId(R, T, _); reviewerDataId(R, _, T)), RL),
   getDomainUnion(RL, RD),
   W1 in RD,
   Id1 is Id + 1,
   expertyReview(L1,Id1).

nonExpertReview([], _).
nonExpertReview(W1, Id) :-
   findall(R, reviewerDataId(R, _, _), RL),
   getDomainUnion(RL, RD),
   W1 ins RD.


% expertyReview([], _).
% expertyReview([W1|L1], Id) :-
%    paperId(Id, _, _, T),
%    findall(R, (reviewerDataId(R, T, _); reviewerDataId(R, _, T)), RL),
%    getDomainUnion(RL, RD),
%    W1 in RD,
%    Id1 is Id + 1,
%    expertyReview(L1, Id1).

reviewerDataId(_, _, _) :- false. % prevent warning

assignDomain4(_, _, []).
assignDomain4(W1, W2, [T|L]) :-
   W1 in T,
   W2 in T,
   assignDomain4(W1, W2, L).

paperHasTwoReviewers([], _).
paperHasTwoReviewers([W1|L1], [W2|L2]) :-
   W1 #\= W2,
   paperHasTwoReviewers(L1, L2).

createPairs([], _, _).
createPairs([R|L], MaxLoad, [P|LP]) :-
   createPairs(L, MaxLoad, LP),
   D in 0..MaxLoad,
   P = R-D.

% # Vs = [_,_,_,_], M in 0..3, N in 0..3, global_cardinality(Vs, [1-M,2-N]), label(Vs).
considerMaxLoad(Reviewers, MaxLoad) :-
   findall(R, reviewerDataId(R, _, _), RL),
   print(Reviewers),
   print(RL),
   createPairs(RL, MaxLoad, Pairs),
   print(Pairs),
   global_cardinality(Reviewers, Pairs).


considerMaxLoad([], _).
considerMaxLoad([R|L], LoadMax) :-
   count(R, L, C),
   C < LoadMax,
   considerMaxLoad(L, LoadMax).

count(_, [], 0) :- !.
count(X, [X|L], N) :-
   !,
   count(X, L, N1),
   N is N1 + 1.
count(X, [_|L], N) :-
   count(X, L, N).

assignRealNames([], _).
assignRealNames([W|WL], [I|IL]) :-
   reviewerId(I, R),
   W = R,
   assignRealNames(WL, IL).

% definePaperNumber([], _, _).
% definePaperNumber([P|Papers], Reviewers, Topics) :-

%    assert(paper(P, RI1, RI2, TI)),
%    definePaperNumber(Papers, Reviewers, Topics).

% paperNumber().

% constrainPaper([], [], _, _).
% constrainPaper([R1|W1], [R2|W2], Reviewers, Index) :-
%    paper(Index, Author1, Author2, _),
%    R1 in Reviewers,
%    R2 in Reviewers,
%    % R1 =\= Author1,
%    % R2 =\= Author1,
%    % R1 =\= Author2,
%    % R2 =\= Author2,
%    Index1 is Index + 1,
%    constrainPaper(W1, W2, Reviewers, Index1).

% consOwnPaper([]).
% consOwnPaper([R|L]) :-
%    xConsOwnPaper(R),
%    consOwnPaper(L).

% xConsOwnPaper(R) :-
%    findall(P1, paper(P1, R, _, _), Papers1),
%    findall(P2, paper(P2, _, R, _), Papers2),
%    append(Papers1, Papers2, Papers3),
%    dontReview(R, Papers3).

% dontReview(_, []).
% dontReview(Reviewer, [P|L]) :-
%    .

% example

paper(1,lily,xxx,ai).
paper(2,peter,john,database).
paper(3,ann,xxx,theory).
paper(4,ken,lily,network).
paper(5,kris,xxx,games).
paper(6,jim,xxx,games).
paper(7,bill,xxx,theory).
paper(8,bill,lily,ai).
paper(9,peter,ann,games).

reviewer(lily,theory,network).
reviewer(john,ai,theory).
reviewer(peter,database,network).
reviewer(ann,theory,network).
reviewer(kris,theory,games).
reviewer(ken,database,games).
reviewer(bill,database,ai).
reviewer(jim,theory,games).
reviewer(kevin,theory,games).
reviewer(paul,ai,network).

workLoadAtMost(2).
